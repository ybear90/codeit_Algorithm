"""
문제를 다른 방향에서 바라보기 위해서 반복문 대신 재귀 함수를 써 봅시다

문제에서 소개된 반복문 솔루션을 그대로 재귀적으로 바꿔 보았습니다. 이 알고리즘 역시 O(y)입니다.

O(y)보다 효율적인 알고리즘이라면 아마 O(lgy)일 텐데요. 어떻게 O(lgy) 알고리즘을 구현할 수 있을까요?

재귀적인 O(y) 솔루션은 문제 크기를 1씩 줄여 나갔습니다. O(lgy)를 위해서는 문제를 나누어야겠죠? 예를 들어서 재귀적 호출이 power(x, y - 1) 대신 power(x, y // 2)와 같은 형태가 될 수 있겠네요.

y가 짝수일 때만 제대로 된 계산을 합니다. y가 홀수일 때도 제대로 동작하도록 작성해 주세요.

어렵지 않습니다. y가 홀수인 경우 그냥 x를 한 번 더 곱해 주면 됩니다.

2^8을 계산한다고 가정합시다. 그러면 power(2, 8)을 호출해야 하는데요. 28은…

24 * 24이 되고,
(22 * 22) * (22 * 22)이 되고,
((2 * 2) * (2 * 2)) * ((2 * 2) * (2 * 2))가 됩니다.
그러니까 결국에는 power(2, 1)을 8번 호출하는 거죠. 추가적으로 power(2, 2), power(2, 4), power(2, 8)에 대한 호출이 몇 번씩 있기 때문에 이 솔루션도 최소 O(y)입니다. 기존 알고리즘에서 전혀 개선되지 않았네요.

뭐가 문제일까요?

power(2, 8)을 해결하기 위해서는 부분 문제 power(2, 4)를 해결하면 되죠? 부분 문제의 최적의 솔루션을 이용해서 기준 문제의 솔루션을 구할 수 있기 때문에 이 문제에는 최적 부분 구조가 있습니다.

그런데 우리는 power(2, 4)라는 똑같은 부분 문제를 두 번 계산해야 합니다. 중복되는 부분 문제가 존재하는 거죠.

최적 부분 구조와 중복되는 부분 문제가 있으니, 이 문제는 Dynamic Programming으로 해결하면 됩니다. 다만, 이 경우에는 일반적인 Memoization이나 Tabulation 방법보다 훨씬 간단하게 해결할 수 있습니다.
"""

def power(x, y):
    if y == 0:
        return 1

    # 계산을 한 번만 하기 위해서 변수에 저장
    subresult = power(x, y // 2)

    # 문제를 최대한 똑같은 크기의 문제 두 개로 나눠준다 (짝수, 홀수 경우 따로)
    if y % 2 == 0:
        return subresult * subresult
    else:
        return x * subresult * subresult

# 테스트
print(power(3, 5))
print(power(5, 6))
print(power(7, 9))