"""
산 정상인 26km 지점에 도착할 때까지 물이 남아 있어야 할 텐데, 그러기 위해서는 최소 22km 지점 이후에 한 번 물을 채워야 합니다.

우리의 경우 22km 지점이나 24km 지점에서 물을 채우면 되겠죠?

그렇다면 26km 약수터에 가장 효율적으로 가는 방법은 이렇습니다.

24km 약수터까지 최대한 효율적으로 가는 방법 + 24km 약수터
22km 약수터까지 최대한 효율적으로 가는 방법 + 22km 약수터
이 두 방법 중 더 효율적인 방법을 선택하면 되겠네요.

부분 문제의 최적의 솔루션을 이용해서 기존 문제의 최적의 솔루션을 구할 수 있기 때문에, 이 문제에는 최적 부분 구조가 있습니다.

최적 부분 구조가 있는 문제가 탐욕적 선택 속성까지 있다면 Greedy Algorithm으로 문제를 풀 수 있습니다.

혹시 이 문제에 탐욕적 선택 속성이 있는지 고민해 보세요.

처음 등산길에 오를 때, 물이 다 떨어지기 전에 갈 수 있는 약수터는 1km 지점과 4km 지점입니다. 두 약수터 중 어디서 채우는 게 더 좋은 선택일까요?

1km 지점에서 물을 채우면, 다음 갈 수 있는 약수터는 4km 지점과 5km 지점입니다. 4km 지점에서 물을 채우면, 다음 갈 수 있는 약수터는 5km 지점이나 7km 지점입니다.

1km 지점과 4km 지점 중 어디로 가는 게 좋을까요?

1km 지점에서 갈 수 있는 약수터는 모두 4km 지점에서도 갈 수 있습니다. 따라서 1km 지점에서 물통을 채울 이유가 전혀 없죠.

항상 가능한 먼 약수터로 가는 것이 가장 좋은 선택이라고 확신할 수 있기 때문에, 이 문제에는 탐욕적 선택 속성이 있습니다.

따라서 이 문제는 Greedy Algorithm을 이용해서 효율적으로 해결할 수 있는 거죠!

인풋 water_stops의 길이를 n이라고 합시다.

함수 select_stops는 n에 비례하는 반복문이 하나 있기 때문에, 시간 복잡도는 O(n)입니다.
"""

def select_stops(water_stops, capacity):
    # 약수터 위치 리스트
    stop_list = []

    # 마지막 들른 약수터 위치
    prev_stop = 0

    for i in range(len(water_stops)):
        # i 지점까지 갈 수 없으면, i - 1 지점 약수터를 들른다
        # 즉 못가는 지점 바로 직전이 갈 수 있는 최대의 지점이 된다는 소리(불가 영역을 이용하여 상한 찾기)
        if water_stops[i] - prev_stop > capacity:
            stop_list.append(water_stops[i - 1])
            prev_stop = water_stops[i - 1]

    # 마지막 약수터는 무조건 간다
    stop_list.append(water_stops[-1])

    return stop_list


# 테스트
list1 = [1, 4, 5, 7, 11, 12, 13, 16, 18, 20, 22, 24, 26]
print(select_stops(list1, 4))

list2 = [5, 8, 12, 17, 20, 22, 23, 24, 28, 32, 38, 42, 44, 47]
print(select_stops(list2, 6))